# MCP server blueprint for bayton.org content

This guide shows one practical way to expose this Eleventy content as an MCP server so AI clients can:

- search the published content,
- fetch page/article metadata,
- retrieve rendered content snippets for grounding.

## Why this approach fits this repository

The site already generates a machine-readable search index at `/search-index.json` from `collections.all`, including `title`, `url`, and parsed `content`. That means your MCP server can use one consistent source for retrieval without needing to parse every template format itself.

## Architecture

1. **Build the site** with Eleventy.
2. **Read `_public/search-index.json`** as the core content catalogue.
3. **Expose MCP tools**:
   - `search_content(query, limit)`
   - `get_content_by_url(url)`
4. **Optionally expose MCP resources** for full-document access.

## Minimal implementation

A ready-to-run, commented example server is provided at:

- `api/mcp/eleventy-content-mcp-server.js`

It uses:

- `@modelcontextprotocol/sdk` for the MCP protocol,
- a small in-memory index loaded from Eleventy output.

## Setup

Install dependencies (inside this repo):

```bash
npm install
```

This package is required at runtime by the MCP server, so install it as a regular dependency for production deployments (including environments that use `npm ci --omit=dev`).

Build content before starting the MCP server:

```bash
npm run build
```

Run the server:

```bash
node api/mcp/eleventy-content-mcp-server.js
```

If you prefer to run it directly via shebang, first make it executable:

```bash
chmod +x api/mcp/eleventy-content-mcp-server.js
./api/mcp/eleventy-content-mcp-server.js
```

## Client configuration example

For MCP clients that support stdio servers, point at an absolute script path in your local clone (or set a compatible working directory):

```json
{
  "mcpServers": {
    "bayton-content": {
      "command": "node",
      "args": [
        "/path/to/repo/api/mcp/eleventy-content-mcp-server.js"
      ]
    }
  }
}
```

## How it works

At runtime, the MCP server follows a simple flow:

1. On startup, it reads `_public/search-index.json` generated by Eleventy.
2. It normalises each entry (`title`, `url`, `content`) and builds an in-memory search field.
3. It opens an MCP stdio transport and registers two tools:
   - `search_content`: keyword match over title + content with a configurable `limit`.
   - `get_content_by_url`: exact lookup for one site URL.
4. MCP clients call those tools using JSON-RPC via stdio, and receive text payloads containing JSON results.

The implementation also validates tool inputs at runtime and returns clear errors when the index file is missing or malformed.




## Remote MCP endpoint on Netlify (`/mcp`)

For direct MCP compatibility on Netlify, this repository now includes a Streamable HTTP MCP function:

- `netlify/functions/mcp.js`

This function exposes your tools at `/mcp` (not only `/.netlify/functions/*`) and is designed for remote MCP clients and proxies.

### Local development

Use Netlify CLI to emulate functions and routing:

```bash
netlify dev
```

Then connect clients to:

- `http://localhost:8888/mcp` (default Netlify CLI port; confirm in your local output)

### Inspecting the remote MCP

```bash
# Local
npx @modelcontextprotocol/inspector npx mcp-remote@next http://localhost:8888/mcp

# Deployed
npx @modelcontextprotocol/inspector npx mcp-remote@next https://<your-domain>/mcp
```

### Claude Desktop configuration example (hybrid compatibility)

```json
{
  "mcpServers": {
    "bayton-content-remote": {
      "command": "npx",
      "args": [
        "mcp-remote@next",
        "https://<your-domain>/mcp"
      ]
    }
  }
}
```

The existing `netlify/functions/mcp-search-content.js` and `netlify/functions/mcp-get-content-by-url.js` endpoints remain useful for simple HTTP integrations, while `/mcp` is the protocol-native route for MCP clients.

## Netlify-compatible HTTP option

If you need this to work inside Netlifyâ€™s serverless runtime, this repository now includes HTTP adapters under `netlify/functions/`:

- `netlify/functions/mcp-search-content.js`
- `netlify/functions/mcp-get-content-by-url.js`

These functions read the same `_public/search-index.json` output and expose equivalent capabilities over HTTP.

### How to call them

After deploying to Netlify:

```bash
# Search by keyword
curl "https://<your-site>.netlify.app/.netlify/functions/mcp-search-content?query=android&limit=3"

# Fetch a document by exact site URL
curl "https://<your-site>.netlify.app/.netlify/functions/mcp-get-content-by-url?url=/android/"
```

Both endpoints also accept `POST` with a JSON body.

Netlify function caching note: the shared index cache is kept per warm function container. New deployments naturally refresh data, but if content changed mid-container lifetime, the old in-memory snapshot may persist briefly until the container recycles.

### Which option should you choose?

- Use `api/mcp/eleventy-content-mcp-server.js` when your client supports stdio MCP and you can run an always-on process.
- Use `netlify/functions/*` when deploying on Netlify and you need request/response HTTP endpoints.

## Netlify and Eleventy

Short answer: **not automatically**.

Netlify will run your configured build command (for example `npm run build`) to generate the static site output, including `_public/search-index.json`. However, a long-running stdio MCP process such as `api/mcp/eleventy-content-mcp-server.js` is **not** started automatically as part of a standard Eleventy static deployment.

If you want MCP in production on Netlify, use one of these approaches:

- host the MCP server on a separate always-on runtime (for example a container/VM) and point clients to that deployment;
- adapt the MCP capabilities into Netlify Functions/Edge Functions patterns where appropriate (request/response), noting this is a different execution model from stdio MCP.

## Production hardening ideas

- Add a build hook so search index refresh happens before MCP server restart.
- Prebuild and persist tokenised content fields (for example, keyword arrays) in the search index for faster loading and matching.
- Add URL allow-listing to avoid exposing unpublished routes.
- Add rate limiting or API gateway controls to reduce abuse and accidental overload.
- Add `lastModified` metadata (for example via git history) in tool responses.
- Add optional semantic retrieval (embeddings) alongside keyword search.

## Optional protocol smoke test

After building the site, you can run an end-to-end MCP check:

```bash
node api/mcp/mcp-smoke-test.js
```

This spawns the server over stdio, performs MCP initialisation, lists tools, and calls each tool once.
